# 线程控制

[TOC]

## 12.2 线程限制

## 12.3 线程属性

1. 初始化

    ```c++
    #include <pthread.h>
    int pthread_attr_init(pthread_attr_t *attr);
    int pthread_attr_destroy(pthread_attr_t *attr);
    ```

2. **detach** : 如果在创建线程时就知道不需要了解线程的终止状态，则可以修改`pthread_attr_t`结构中的`detachstates`线程属性，让线程以分离状态启动。可以使用`pthread_attr_setdetachstate`函数把线程属性`detachstate`设置为下面的两个合法的值：`PTHREAD_CREATE_DETDACHED`和`PTHREAD_CREATE_JOINABLE`

    ```c++
    int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);
    // detachstate：
    //      PTHREAD_CREATE_DETDACHED
    //      PTHREAD_CREATE_JOINABLE
    int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate);
    ```

3. 设置线程栈地址，栈可以由malloc和mmap分配获得

    ```c++
    #include <pthread.h>
    int pthread_attr_setstack(pthread_attr_t *attr,
                                void *stackaddr, size_t stacksize);
    int pthread_attr_getstack(const pthread_attr_t *attr,
                                void **stackaddr, size_t *stacksize);
    ```

4. 设置和获取栈大小

    ```c++
    int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);
    int pthread_attr_getstacksize(const pthread_attr_t *attr, size_t *stacksize);
    ```

5. 设置栈警戒区大小（没用过）

    ```c++
    int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);
    int pthread_attr_getstacksize(const pthread_attr_t *attr, size_t *stacksize);
    ```

## 12.4 同步属性

### 互斥量属性

1. 初始化

    ```c++
    int pthread_mutexattr_destroy(pthread_mutexattr_t *attr);
    int pthread_mutexattr_init(pthread_mutexattr_t *attr);
    ```

2. **进程共享属性**： 相互独立的多个进程把同一个内存区映射到他们各自的地址空间中。然后从多个进程共享的内存区域中分配的互斥量可以用于进程的同步。

    ```c++
    int pthread_mutexattr_getpshared(const pthread_mutexattr_t *attr,
                                    int *pshared);
    int pthread_mutexattr_setpshared(pthread_mutexattr_t *attr,
                                    int pshared);
    // pshared:
    //          PTHREAD_PROCESS_SHARED   设置为进程共享锁
    //          PTHREAD_PROCESS_PRIVATE  设置为进程私有的锁
    ```

3. **互斥量类型属性**

    ```c++
    int pthread_mutexattr_gettype(const pthread_mutexattr_t *restrict attr,
        int *restrict type);
    int pthread_mutexattr_settype(pthread_mutexattr_t *attr, int type);
    ```

    类型          | 没有解锁时再次加锁 | 不占用时解锁 | 在已解锁时加锁
    -|-|-|-
    PTHREAD_MUTEX_NORMAL     | 死锁     | 未定义  | 未定义
    PTHREAD_MUTEX_ERRORCHECK | 返回错误 | 返回错误 | 返回错误
    PTHREAD_MUTEX_RECURSIVE  | 允许     | 返回错误 | 返回错误
    PTHREAD_MUTEX_DEFAULT    | 未定义   | 未定义   | 未定义

### 读写锁属性

1. 初始化

    ```c++
    int pthread_rwlockattr_destroy(pthread_rwlockattr_t *attr);
    int pthread_rwlockattr_init(pthread_rwlockattr_t *attr);
    ```

2. 进程共享属性(和互斥锁的进程共享属性一样)

    ```c++
    int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t
        *restrict attr, int *restrict pshared);
    int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *attr,
        int pshared);
    ```

### 条件变量属

1. 初始化

    ```c++
    int pthread_rwlockattr_destroy(pthread_rwlockattr_t *attr);
    int pthread_rwlockattr_init(pthread_rwlockattr_t *attr);
    ```

2. 进程共享属性

    ```c++
    int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t
           *restrict attr, int *restrict pshared);
    int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *attr,
           int pshared);
    ```

## 12.5 重入

如果一个函数在同一时刻可以被多个线程安全地调用，就称该函数是线程安全的

## 12.6 线程私有数据

```c++
int pthread_key_create(pthread_key_t *key, void (*destructor)(void*));
// 调用pthread_exit或者线程执行返回，正常退出时，析构函数就会被调用。

int pthread_key_delete(pthread_key_t key);
// 取消键与线程私有数据之间的关联关系。
// 调用此函数并不会激活与键关联的析构函数。

void *pthread_getspecific(pthread_key_t key);
// 获取key的关联value

int pthread_setspecific(pthread_key_t key, const void *value);
// 设置key和value的关联


```

使用pthread_once函数，当在所有的进程中调用此函数，此函数只会执行一次：

```c++
#include <pthread.h>

int pthread_once(pthread_once_t *once_control,
    void (*init_routine)(void));
pthread_once_t once_control = PTHREAD_ONCE_INIT; // 每个pthread_once函数都必须引用相同的once_control， 执行后 once_control会变成其他值导致其他线程的pthread_once函数不再执行。
```

## 12.7 取消选项

可以设置线程取消属性：
PTHREAD_CANCEL_ENABLE:  表示其他线程调用pthread_cancel函数可以请求取消线程
PTHREAD_CANCEL_DISABLE： 表示pthread_cancel的调用不会取消线程，直到设置回到PTHREAD_CANCEL_ENABLE，线程就会在下一个取消点取消

```c++
int pthread_setcancelstate(int state, int *oldstate);
```

使用pthread_testcancel也可以检查线程是否被取消

* 延迟取消和异步取消
异步取消不用等待检查点，延时取消需要等待检查点

设置为异步取消

```c++
int pthread_setcanceltype(int type, int *oldtype);
// PTHREAD_CANCEL_DEFERRED PTHREAD_CANCEL_ASYNCHRONOUS
```

## 12.8 线程和信号

* 每个线程都有信号屏蔽字
* 修改信号处理函数会应用于所有的线程
* 

## 12.9 线程中调用fork


